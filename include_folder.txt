# Source Code Collection
# Generated on: 2025-04-13 01:01:02
# Root path: C:\Users\danny\source\repos\MultiSourceFileCopier\include


=================================================================
FILE: MainWindow.h
=================================================================

#pragma once


=================================================================
FILE: SpeedMeasure.h
=================================================================

#pragma once
#include <string>
#include <vector>
#include <memory>
#include <windows.h>

class SpeedMeasure {
public:
    SpeedMeasure();
    ~SpeedMeasure();

    // Measure speed of a single source file
    // Returns speed in Kbps, or -1 on error
    long long MeasureSourceSpeed(const std::wstring& sourcePath);

    // Measure speeds of a list of sources and sort by speed (descending)
    // Returns true if successful, false otherwise
    // The input vector is modified to contain paths sorted by speed
    bool MeasureAndSortSources(std::vector<std::wstring>& sources);

private:
    // Read a sample of data to measure speed
    // Returns speed in Kbps, or -1 on error
    long long MeasureFileSpeed(HANDLE hFile);

    // Sample buffer size for measurement (64KB is a good starting point)
    static const DWORD SAMPLE_SIZE = 64 * 1024;

    // Reusable buffer to avoid repeated allocations
    std::unique_ptr<BYTE[]> m_buffer;
};

=================================================================
FILE: GuiControls.h
=================================================================

#pragma once
#include <windows.h>
#include <commctrl.h>
#include <string>
#include <vector>
#include "../include/FileCopier.h"
#include "../include/SpeedMeasure.h"

// Control IDs
#define ID_SOURCE_LISTVIEW     1001
#define ID_DESTINATION_EDIT    1002
#define ID_BROWSE_BUTTON       1003
#define ID_ADD_SOURCE_BUTTON   1004
#define ID_REMOVE_BUTTON       1005
#define ID_MEASURE_BUTTON      1006
#define ID_START_BUTTON        1007
#define ID_CANCEL_BUTTON       1008
#define ID_PROGRESS_BAR        1009
#define ID_STATUS_BAR          1010
#define ID_PACKET_SIZE_COMBO   1011

// Window class name
#define WINDOW_CLASS_NAME L"MultiSourceFileCopierClass"

// Message for updating the progress bar (to avoid cross-thread UI updates)
#define WM_UPDATE_PROGRESS (WM_USER + 1)
#define WM_COPY_COMPLETE   (WM_USER + 2)

// Main application window class
class MainWindow {
public:
    MainWindow(HINSTANCE hInstance);
    ~MainWindow();

    // Initialize the window
    bool Initialize(int nCmdShow);

    // Run message loop
    int Run();

private:
    // Window procedure
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // UI functions
    void CreateControls(HWND hwnd);
    void ResizeControls(HWND hwnd);
    void UpdateSourceList();
    void UpdateStatusText(const wchar_t* text);
    void SetProgress(int percent);
    void EnableCopyControls(bool enable);

    // Action handlers
    void OnAddSource();
    void OnRemoveSource();
    void OnBrowseDestination();
    void OnMeasureSpeeds();
    void OnStartCopy();
    void OnCancelOperation();
    void OnCopyComplete(bool success);

    // Progress callback
    static void ProgressCallback(int completed, int total, void* userData);

    // Member variables
    HWND m_hwnd;                // Main window handle
    HWND m_sourceListView;      // List view control for sources
    HWND m_destinationEdit;     // Edit control for destination
    HWND m_progressBar;         // Progress bar
    HWND m_statusBar;           // Status bar
    HWND m_packetSizeCombo;     // Packet size combo box
    HINSTANCE m_hInstance;      // Application instance

    FileCopier m_fileCopier;    // File copier instance
    SpeedMeasure m_speedMeasure; // Speed measurement

    // Helper methods
    int GetSelectedPacketSize();
};

=================================================================
FILE: FileCopier.h
=================================================================

#pragma once

#include <string>
#include <vector>
#include <memory>
#include <windows.h>

// Add forward declarations for Boost
namespace boost {
    class thread;
    class thread_group;
    class mutex;
    class condition_variable;
    template <typename T> class atomic;
}

// Progress callback function type
typedef void (*ProgressCallbackFunc)(int completed, int total, void* userData);

// Source file information
struct SourceInfo {
    std::wstring path;        // File path
    std::wstring status;      // Current status (e.g., "Ready", "Copying", etc.)
    long long speed;          // Measured speed in Kbps
};

// Thread parameter structure
struct CopyThreadParam {
    class FileCopier* pCopier;
};

class FileCopier {
public:
    FileCopier();
    ~FileCopier();

    // Add a source file
    void AddSource(const std::wstring& path);

    // Remove a source file
    void RemoveSource(size_t index);

    // Clear all sources
    void ClearSources();

    // Get list of sources
    const std::vector<SourceInfo>& GetSources() const;

    // Start copying files
    bool StartCopy(
        const std::wstring& destinationPath,
        ProgressCallbackFunc progressCallback,
        void* userData,
        int packetSize = 65536    // 64KB default
    );

    // Cancel the copy operation
    void Cancel();

    // Check if a copy is in progress
    bool IsOperationInProgress() const;

    // Friend function for thread procedure
    friend DWORD WINAPI CopyThreadProc(LPVOID lpParameter);

private:
    // Copy operation function
    void DoCopyOperation();

    // Copy a single packet from source to destination
    bool CopyPacket(
        const std::wstring& sourcePath,
        HANDLE hDestFile,
        LARGE_INTEGER offset,
        DWORD packetSize,
        int packetIndex,
        BYTE* buffer
    );

    // Member variables
    std::vector<SourceInfo> m_sources;
    std::wstring m_destinationPath;
    std::wstring m_destinationFilename;
    int m_packetSize;
    ProgressCallbackFunc m_progressCallback;
    void* m_userData;

    // Threading
    HANDLE m_thread;
    HANDLE m_cancelEvent;
    CopyThreadParam m_threadParam;
    bool m_operationInProgress;

    // Progress tracking
    int m_totalPackets;
    int m_completedPackets;
    CRITICAL_SECTION m_cs;  // For thread synchronization

    // Optimizations
    std::unique_ptr<BYTE[]> m_buffer;  // Reusable buffer for copying
    static const DWORD BUFFER_SIZE = 1024 * 1024;  // 1MB buffer
};

// Thread procedure (declared outside of class for Win32 API compatibility)
DWORD WINAPI CopyThreadProc(LPVOID lpParameter);

=================================================================
FILE: resource.h
=================================================================

#pragma once

// Resource definitions
#define IDI_APP_ICON                    101
#define IDD_ABOUTBOX                    102
#define IDM_ABOUT                       103
#define IDM_EXIT                        104
#define IDC_STATIC                      -1

=================================================================
FILE: src_folder.txt
=================================================================

# Source Code Collection
# Generated on: 2025-04-13 01:00:33
# Root path: C:\Users\danny\source\repos\MultiSourceFileCopier\src


=================================================================
FILE: main.cpp
=================================================================

#include <windows.h>
#include <commctrl.h>
#include "../include/GuiControls.h"

// Link with necessary libraries
#pragma comment(lib, "comdlg32.lib")  // For GetOpenFileName
#pragma comment(lib, "shell32.lib")   // For SHBrowseForFolder and SHGetPathFromIDList

// Initialize Common Controls
void InitializeCommonControls()
{
    // Initialize common controls
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_BAR_CLASSES |
        ICC_STANDARD_CLASSES | ICC_WIN95_CLASSES;
    InitCommonControlsEx(&icc);
}

// Entry point
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
    // Initialize COM for shell functions
    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
    {
        MessageBox(NULL, L"COM initialization failed!", L"Error", MB_ICONERROR);
        return 1;
    }

    // Initialize common controls
    InitializeCommonControls();

    // Create and initialize the main window
    MainWindow mainWindow(hInstance);
    if (!mainWindow.Initialize(nCmdShow))
    {
        CoUninitialize();
        return 1;
    }

    // Run the message loop
    int result = mainWindow.Run();

    // Clean up COM
    CoUninitialize();

    return result;
}

=================================================================
FILE: resource.h
=================================================================

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif


=================================================================
FILE: SpeedMeasure.cpp
=================================================================

#include "../include/SpeedMeasure.h"
#include <algorithm>
#include <map>

SpeedMeasure::SpeedMeasure()
{
    // Allocate the measurement buffer
    m_buffer = std::make_unique<BYTE[]>(SAMPLE_SIZE);
}

SpeedMeasure::~SpeedMeasure()
{
    // Buffer will be automatically cleaned up by unique_ptr
}

// Measure speed of a single source file
long long SpeedMeasure::MeasureSourceSpeed(const std::wstring& sourcePath)
{
    // Open the file
    HANDLE hFile = CreateFile(
        sourcePath.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return -1;  // Error opening file
    }

    // Measure the file speed
    long long speed = MeasureFileSpeed(hFile);

    // Close the file
    CloseHandle(hFile);

    return speed;
}

// Measure speeds of a list of sources and sort by speed
bool SpeedMeasure::MeasureAndSortSources(std::vector<std::wstring>& sources)
{
    if (sources.empty())
    {
        return false;
    }

    // Map of source paths to their speeds
    std::map<std::wstring, long long> sourceSpeedMap;

    // Measure each source
    for (const auto& path : sources)
    {
        long long speed = MeasureSourceSpeed(path);
        sourceSpeedMap[path] = speed;
    }

    // Sort the sources by speed (descending)
    std::sort(sources.begin(), sources.end(),
        [&sourceSpeedMap](const std::wstring& a, const std::wstring& b) {
            return sourceSpeedMap[a] > sourceSpeedMap[b];
        });

    return true;
}

// Read a sample of data to measure speed
long long SpeedMeasure::MeasureFileSpeed(HANDLE hFile)
{
    if (!m_buffer)
    {
        return -1;  // Buffer not available
    }

    // Try multiple measurements and take the average for more accuracy
    const int NUM_MEASUREMENTS = 3;
    long long totalSpeed = 0;
    int validMeasurements = 0;

    for (int i = 0; i < NUM_MEASUREMENTS; i++)
    {
        // Choose a different position in the file for each measurement
        LARGE_INTEGER fileSize;
        if (!GetFileSizeEx(hFile, &fileSize))
        {
            return -1;
        }

        // Skip this measurement if file is too small
        if (fileSize.QuadPart < SAMPLE_SIZE)
        {
            if (i == 0)
            {
                // If first measurement, try to read what we can
                SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
            }
            else
            {
                // Otherwise skip this measurement
                continue;
            }
        }
        else
        {
            // Find a suitable random position, avoiding the very beginning and end
            // Use a simple algorithm to distribute the positions across the file
            LONGLONG position = 0;
            if (fileSize.QuadPart > SAMPLE_SIZE * 3)
            {
                position = (fileSize.QuadPart / 4) * (i + 1);
                position = min(position, fileSize.QuadPart - SAMPLE_SIZE * 2);
            }

            // Set the file pointer to the calculated position
            LARGE_INTEGER distanceToMove;
            distanceToMove.QuadPart = position;
            if (!SetFilePointerEx(hFile, distanceToMove, NULL, FILE_BEGIN))
            {
                return -1;
            }
        }

        // Get starting time with high precision
        LARGE_INTEGER frequency, startTime, endTime;
        QueryPerformanceFrequency(&frequency);
        QueryPerformanceCounter(&startTime);

        // Read a sample from the file
        DWORD bytesRead = 0;
        BOOL result = ReadFile(hFile, m_buffer.get(), SAMPLE_SIZE, &bytesRead, NULL);

        // Get ending time
        QueryPerformanceCounter(&endTime);

        // Calculate speed
        if (result && bytesRead > 0)
        {
            // Calculate elapsed time in seconds
            double elapsedSeconds = static_cast<double>(endTime.QuadPart - startTime.QuadPart) /
                static_cast<double>(frequency.QuadPart);

            if (elapsedSeconds > 0.0)
            {
                // Calculate speed in Kbps (kilobits per second)
                // 8 bits per byte, 1000 bits per Kbit
                long long speedKbps = static_cast<long long>((bytesRead * 8) / (elapsedSeconds * 1000));
                totalSpeed += speedKbps;
                validMeasurements++;
            }
        }
    }

    // Calculate average speed
    if (validMeasurements > 0)
    {
        return totalSpeed / validMeasurements;
    }

    return -1;  // No valid measurements
}

=================================================================
FILE: GuiControls.cpp
=================================================================

#include "../include/GuiControls.h"
#include <windowsx.h>
#include <shlobj.h>
#include <strsafe.h>

// Constructor
MainWindow::MainWindow(HINSTANCE hInstance)
    : m_hInstance(hInstance),
    m_hwnd(nullptr),
    m_sourceListView(nullptr),
    m_destinationEdit(nullptr),
    m_progressBar(nullptr),
    m_statusBar(nullptr),
    m_packetSizeCombo(nullptr)
{
}

// Destructor
MainWindow::~MainWindow()
{
    // Cleanup if needed
}

// Initialize the main window
bool MainWindow::Initialize(int nCmdShow)
{
    // Register the window class
    WNDCLASSEX wcex = { 0 };
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WindowProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = m_hInstance;
    wcex.hIcon = LoadIcon(m_hInstance, IDI_APPLICATION);
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszMenuName = nullptr;
    wcex.lpszClassName = WINDOW_CLASS_NAME;
    wcex.hIconSm = LoadIcon(wcex.hInstance, IDI_APPLICATION);

    if (!RegisterClassEx(&wcex))
    {
        MessageBox(nullptr, L"Window Registration Failed!", L"Error", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }

    // Calculate centered window position
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);
    int windowWidth = 800;
    int windowHeight = 700;
    int windowX = (screenWidth - windowWidth) / 2;
    int windowY = (screenHeight - windowHeight) / 2;

    // Create the main window
    m_hwnd = CreateWindow(
        WINDOW_CLASS_NAME,
        L"Multi-Source File Copy Utility",
        WS_OVERLAPPEDWINDOW,
        windowX, windowY, windowWidth, windowHeight,
        nullptr, nullptr, m_hInstance, this);  // Pass 'this' pointer for use in WindowProc

    if (!m_hwnd)
    {
        MessageBox(nullptr, L"Window Creation Failed!", L"Error", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }

    // Create all the UI controls
    CreateControls(m_hwnd);

    // Show and update the window
    ShowWindow(m_hwnd, nCmdShow);
    UpdateWindow(m_hwnd);

    return true;
}

// Run the message loop
int MainWindow::Run()
{
    MSG msg = { 0 };
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return (int)msg.wParam;
}

// Static window procedure
LRESULT CALLBACK MainWindow::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MainWindow* pThis = nullptr;

    // On window creation, store the MainWindow instance pointer
    if (uMsg == WM_NCCREATE)
    {
        CREATESTRUCT* pCreate = (CREATESTRUCT*)lParam;
        pThis = (MainWindow*)pCreate->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
    }
    else
    {
        // Retrieve the MainWindow instance pointer
        pThis = (MainWindow*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    // Call the member function to handle the message
    if (pThis)
    {
        return pThis->HandleMessage(hwnd, uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

// Member window procedure implementation
LRESULT MainWindow::HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_COMMAND:
    {
        int wmId = LOWORD(wParam);
        switch (wmId)
        {
        case ID_ADD_SOURCE_BUTTON:
            OnAddSource();
            break;

        case ID_REMOVE_BUTTON:
            OnRemoveSource();
            break;

        case ID_BROWSE_BUTTON:
            OnBrowseDestination();
            break;

        case ID_MEASURE_BUTTON:
            OnMeasureSpeeds();
            break;

        case ID_START_BUTTON:
            OnStartCopy();
            break;

        case ID_CANCEL_BUTTON:
            OnCancelOperation();
            break;

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }
    break;

    case WM_SIZE:
        // Resize all controls when the window is resized
        ResizeControls(hwnd);
        break;

    case WM_UPDATE_PROGRESS:
        // Update progress from worker thread
        SetProgress((int)wParam);
        break;

    case WM_COPY_COMPLETE:
        // Copy operation completed
        OnCopyComplete((bool)wParam);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

// Create all the UI controls
void MainWindow::CreateControls(HWND hwnd)
{
    // Create group box for sources
    CreateWindow(
        L"BUTTON", L"Source Files",
        WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
        10, 10, 760, 320,
        hwnd, nullptr, m_hInstance, nullptr);

    // Create source list view with columns
    m_sourceListView = CreateWindowEx(
        WS_EX_CLIENTEDGE, WC_LISTVIEW, L"",
        WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SHOWSELALWAYS,
        20, 30, 740, 250,
        hwnd, (HMENU)ID_SOURCE_LISTVIEW, m_hInstance, nullptr);

    // Set extended list view styles
    ListView_SetExtendedListViewStyle(m_sourceListView, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);

    // Add columns to the list view
    LVCOLUMN lvc = { 0 };
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;

    // Path column
    lvc.iSubItem = 0;
    lvc.cx = 440;
    lvc.pszText = L"Source Path";
    ListView_InsertColumn(m_sourceListView, 0, &lvc);

    // Status column
    lvc.iSubItem = 1;
    lvc.cx = 100;
    lvc.pszText = L"Status";
    ListView_InsertColumn(m_sourceListView, 1, &lvc);

    // Speed column
    lvc.iSubItem = 2;
    lvc.cx = 120;
    lvc.pszText = L"Speed (Mbps)";
    ListView_InsertColumn(m_sourceListView, 2, &lvc);

    // Create buttons for source actions
    CreateWindow(
        L"BUTTON", L"Add Source",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        20, 290, 120, 30,
        hwnd, (HMENU)ID_ADD_SOURCE_BUTTON, m_hInstance, nullptr);

    CreateWindow(
        L"BUTTON", L"Remove",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        150, 290, 120, 30,
        hwnd, (HMENU)ID_REMOVE_BUTTON, m_hInstance, nullptr);

    CreateWindow(
        L"BUTTON", L"Measure Speeds",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        280, 290, 140, 30,
        hwnd, (HMENU)ID_MEASURE_BUTTON, m_hInstance, nullptr);

    // Create group box for destination
    CreateWindow(
        L"BUTTON", L"Destination",
        WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
        10, 340, 760, 60,
        hwnd, nullptr, m_hInstance, nullptr);

    // Create destination controls
    CreateWindow(
        L"STATIC", L"Folder:",
        WS_CHILD | WS_VISIBLE,
        20, 365, 50, 20,
        hwnd, nullptr, m_hInstance, nullptr);

    m_destinationEdit = CreateWindowEx(
        WS_EX_CLIENTEDGE, L"EDIT", L"",
        WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | ES_READONLY,
        80, 365, 580, 25,
        hwnd, (HMENU)ID_DESTINATION_EDIT, m_hInstance, nullptr);

    CreateWindow(
        L"BUTTON", L"Browse...",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        670, 365, 90, 25,
        hwnd, (HMENU)ID_BROWSE_BUTTON, m_hInstance, nullptr);

    // Create group box for settings
    CreateWindow(
        L"BUTTON", L"Settings",
        WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
        10, 410, 760, 60,
        hwnd, nullptr, m_hInstance, nullptr);

    // Create packet size dropdown
    CreateWindow(
        L"STATIC", L"Packet Size:",
        WS_CHILD | WS_VISIBLE,
        20, 435, 80, 20,
        hwnd, nullptr, m_hInstance, nullptr);

    m_packetSizeCombo = CreateWindow(
        L"COMBOBOX", L"",
        WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL,
        110, 435, 150, 200,
        hwnd, (HMENU)ID_PACKET_SIZE_COMBO, m_hInstance, nullptr);

    // Add packet size options
    ComboBox_AddString(m_packetSizeCombo, L"16 KB");
    ComboBox_AddString(m_packetSizeCombo, L"32 KB");
    ComboBox_AddString(m_packetSizeCombo, L"64 KB");
    ComboBox_AddString(m_packetSizeCombo, L"128 KB");
    ComboBox_AddString(m_packetSizeCombo, L"256 KB");
    ComboBox_AddString(m_packetSizeCombo, L"512 KB");
    ComboBox_AddString(m_packetSizeCombo, L"1 MB");
    ComboBox_SetCurSel(m_packetSizeCombo, 2);  // Default to 64 KB

    // Create progress bar group
    CreateWindow(
        L"BUTTON", L"Progress",
        WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
        10, 480, 760, 40,
        hwnd, nullptr, m_hInstance, nullptr);

    // Create progress bar
    m_progressBar = CreateWindowEx(
        0, PROGRESS_CLASS, L"",
        WS_CHILD | WS_VISIBLE,
        20, 500, 740, 30,
        hwnd, (HMENU)ID_PROGRESS_BAR, m_hInstance, nullptr);

    // Initialize progress bar range (0-100)
    SendMessage(m_progressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100));

    // Create action buttons
    CreateWindow(
        L"BUTTON", L"Start Copy",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        280, 530, 120, 30,
        hwnd, (HMENU)ID_START_BUTTON, m_hInstance, nullptr);

    HWND hCancelButton = CreateWindow(
        L"BUTTON", L"Cancel",
        WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | WS_DISABLED,
        410, 530, 120, 30,
        hwnd, (HMENU)ID_CANCEL_BUTTON, m_hInstance, nullptr);

    // Status bar at the bottom
    m_statusBar = CreateWindowEx(
        0, STATUSCLASSNAME, L"",
        WS_CHILD | WS_VISIBLE | SBARS_SIZEGRIP,
        0, 0, 0, 0,
        hwnd, (HMENU)ID_STATUS_BAR, m_hInstance, nullptr);

    // Set initial status text
    UpdateStatusText(L"Ready");
}

// Resize controls when the window is resized
void MainWindow::ResizeControls(HWND hwnd)
{
    RECT rcClient;
    GetClientRect(hwnd, &rcClient);

    int width = rcClient.right - rcClient.left;
    int height = rcClient.bottom - rcClient.top;

    // Resize and reposition groups
    SetWindowPos(GetDlgItem(hwnd, 0), nullptr, 10, 10, width - 20, 320, SWP_NOZORDER);
    SetWindowPos(GetDlgItem(hwnd, 0), nullptr, 10, 340, width - 20, 60, SWP_NOZORDER);
    SetWindowPos(GetDlgItem(hwnd, 0), nullptr, 10, 410, width - 20, 60, SWP_NOZORDER);
    SetWindowPos(GetDlgItem(hwnd, 0), nullptr, 10, 480, width - 20, 40, SWP_NOZORDER);

    // Resize list view
    SetWindowPos(m_sourceListView, nullptr, 20, 30, width - 40, 250, SWP_NOZORDER);

    // Update destination edit control width
    SetWindowPos(m_destinationEdit, nullptr, 80, 365, width - 200, 25, SWP_NOZORDER);

    // Update browse button position
    SetWindowPos(GetDlgItem(hwnd, ID_BROWSE_BUTTON), nullptr, width - 110, 365, 90, 25, SWP_NOZORDER);

    // Update progress bar width
    SetWindowPos(m_progressBar, nullptr, 20, 500, width - 40, 15, SWP_NOZORDER);

    // Update action buttons position
    SetWindowPos(GetDlgItem(hwnd, ID_START_BUTTON), nullptr, (width / 2) - 130, 530, 120, 30, SWP_NOZORDER);
    SetWindowPos(GetDlgItem(hwnd, ID_CANCEL_BUTTON), nullptr, (width / 2) + 10, 530, 120, 30, SWP_NOZORDER);

    // Position status bar
    SendMessage(m_statusBar, WM_SIZE, 0, 0);
}

// Update source list view
void MainWindow::UpdateSourceList()
{
    // Clear the list view
    ListView_DeleteAllItems(m_sourceListView);

    // Get sources from file copier
    const std::vector<SourceInfo>& sources = m_fileCopier.GetSources();

    // Add each source to the list view
    for (size_t i = 0; i < sources.size(); i++)
    {
        const SourceInfo& source = sources[i];

        // Add item with path
        LVITEM lvi = { 0 };
        lvi.mask = LVIF_TEXT;
        lvi.iItem = (int)i;
        lvi.iSubItem = 0;
        lvi.pszText = (LPWSTR)source.path.c_str();

        int index = ListView_InsertItem(m_sourceListView, &lvi);

        // Set status text
        ListView_SetItemText(m_sourceListView, index, 1, (LPWSTR)source.status.c_str());

        // Set speed value (as text)
        if (source.speed > 0)
        {
            WCHAR speedText[32];
            StringCchPrintf(speedText, 32, L"%.2f", source.speed / 1000.0); // Convert to Mbps
            ListView_SetItemText(m_sourceListView, index, 2, speedText);
        }
        else
        {
            ListView_SetItemText(m_sourceListView, index, 2, L"-");
        }
    }
}

// Update status text
void MainWindow::UpdateStatusText(const wchar_t* text)
{
    SendMessage(m_statusBar, SB_SETTEXT, 0, (LPARAM)text);
}

// Set progress bar value
void MainWindow::SetProgress(int percent)
{
    SendMessage(m_progressBar, PBM_SETPOS, (WPARAM)percent, 0);
}

// Enable/disable copy controls
void MainWindow::EnableCopyControls(bool enable)
{
    EnableWindow(GetDlgItem(m_hwnd, ID_ADD_SOURCE_BUTTON), enable);
    EnableWindow(GetDlgItem(m_hwnd, ID_REMOVE_BUTTON), enable);
    EnableWindow(GetDlgItem(m_hwnd, ID_MEASURE_BUTTON), enable);
    EnableWindow(GetDlgItem(m_hwnd, ID_START_BUTTON), enable);
    EnableWindow(GetDlgItem(m_hwnd, ID_BROWSE_BUTTON), enable);
    EnableWindow(m_packetSizeCombo, enable);
    EnableWindow(GetDlgItem(m_hwnd, ID_CANCEL_BUTTON), !enable);
}

// Get selected packet size in bytes
int MainWindow::GetSelectedPacketSize()
{
    int index = ComboBox_GetCurSel(m_packetSizeCombo);
    if (index == CB_ERR)
        return 64 * 1024; // Default to 64 KB

    // Calculate packet size based on selection
    // 16KB * 2^index
    return 16 * 1024 * (1 << index);
}

// Add source button click handler
void MainWindow::OnAddSource()
{
    OPENFILENAME ofn = { 0 };
    WCHAR szFile[MAX_PATH * 100] = { 0 }; // Buffer for multiple files

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile) / sizeof(WCHAR);
    ofn.lpstrFilter = L"All Files\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT | OFN_EXPLORER;

    if (GetOpenFileName(&ofn))
    {
        // Check if single or multiple files selected
        if (ofn.nFileOffset < lstrlen(szFile))
        {
            // Single file selected
            m_fileCopier.AddSource(szFile);
        }
        else
        {
            // Multiple files selected
            WCHAR directory[MAX_PATH] = { 0 };
            StringCchCopy(directory, MAX_PATH, szFile);

            WCHAR* p = szFile + ofn.nFileOffset;
            while (*p)
            {
                WCHAR fullPath[MAX_PATH];
                StringCchPrintf(fullPath, MAX_PATH, L"%s\\%s", directory, p);

                m_fileCopier.AddSource(fullPath);

                // Move to next file name
                p += lstrlen(p) + 1;
            }
        }

        UpdateSourceList();
        UpdateStatusText(L"Source files added");
    }
}

// Remove source button click handler
void MainWindow::OnRemoveSource()
{
    // Get selected item
    int selectedIndex = ListView_GetNextItem(m_sourceListView, -1, LVNI_SELECTED);
    if (selectedIndex >= 0)
    {
        m_fileCopier.RemoveSource(selectedIndex);
        UpdateSourceList();
        UpdateStatusText(L"Source file removed");
    }
}

// Browse destination button click handler
void MainWindow::OnBrowseDestination()
{
    BROWSEINFO bi = { 0 };
    bi.hwndOwner = m_hwnd;
    bi.lpszTitle = L"Select destination folder";
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl)
    {
        WCHAR path[MAX_PATH];
        if (SHGetPathFromIDList(pidl, path))
        {
            SetWindowText(m_destinationEdit, path);
            UpdateStatusText(L"Destination folder selected");
        }

        CoTaskMemFree(pidl);
    }
}

// Measure speeds button click handler
void MainWindow::OnMeasureSpeeds()
{
    const std::vector<SourceInfo>& sources = m_fileCopier.GetSources();
    if (sources.empty())
    {
        MessageBox(m_hwnd, L"Please add at least one source file.", L"No Sources", MB_OK | MB_ICONINFORMATION);
        return;
    }

    // Disable controls during measurement
    EnableCopyControls(false);
    UpdateStatusText(L"Measuring source speeds...");

    // Create a list of paths to measure
    std::vector<std::wstring> paths;
    for (const auto& source : sources)
    {
        paths.push_back(source.path);
    }

    // Measure and sort the sources
    if (m_speedMeasure.MeasureAndSortSources(paths))
    {
        // Clear existing sources and add them back in sorted order
        m_fileCopier.ClearSources();
        for (const auto& path : paths)
        {
            m_fileCopier.AddSource(path);
        }

        UpdateSourceList();
        UpdateStatusText(L"Sources measured and sorted by speed");
    }
    else
    {
        UpdateStatusText(L"Error measuring source speeds");
    }

    // Re-enable controls
    EnableCopyControls(true);
}

// Start copy button click handler
void MainWindow::OnStartCopy()
{
    const std::vector<SourceInfo>& sources = m_fileCopier.GetSources();
    if (sources.empty())
    {
        MessageBox(m_hwnd, L"Please add at least one source file.", L"No Sources", MB_OK | MB_ICONINFORMATION);
        return;
    }

    // Get destination folder
    WCHAR destinationPath[MAX_PATH];
    GetWindowText(m_destinationEdit, destinationPath, MAX_PATH);

    if (lstrlen(destinationPath) == 0)
    {
        MessageBox(m_hwnd, L"Please select a destination folder.", L"No Destination", MB_OK | MB_ICONINFORMATION);
        return;
    }

    // Disable controls during copy
    EnableCopyControls(false);

    // Reset progress bar
    SetProgress(0);
    UpdateStatusText(L"Starting copy operation...");

    // Get packet size from combo box
    int packetSize = GetSelectedPacketSize();

    // Start the copy operation
    if (!m_fileCopier.StartCopy(destinationPath, ProgressCallback, this, packetSize))
    {
        MessageBox(m_hwnd, L"Failed to start copy operation.", L"Error", MB_OK | MB_ICONERROR);
        // Re-enable controls
        EnableCopyControls(true);
    }
}

// Cancel button click handler
void MainWindow::OnCancelOperation()
{
    m_fileCopier.Cancel();
    UpdateStatusText(L"Cancelling operation...");
}

// Copy complete handler
void MainWindow::OnCopyComplete(bool success)
{
    if (success)
    {
        UpdateStatusText(L"Copy operation completed successfully.");
    }
    else
    {
        UpdateStatusText(L"Copy operation cancelled or failed.");
    }

    // Re-enable controls
    EnableCopyControls(true);
}

// Progress callback function (static)
void MainWindow::ProgressCallback(int completed, int total, void* userData)
{
    MainWindow* pThis = static_cast<MainWindow*>(userData);
    if (pThis)
    {
        // Calculate percentage
        int percent = (total > 0) ? (completed * 100) / total : 0;

        // Update UI (thread-safe using messages)
        PostMessage(pThis->m_hwnd, WM_UPDATE_PROGRESS, (WPARAM)percent, 0);

        // Update status text
        WCHAR statusText[128];
        StringCchPrintf(statusText, 128, L"Copying: %d of %d packets (%d%%)", completed, total, percent);
        SendMessage(pThis->m_statusBar, SB_SETTEXT, 0, (LPARAM)statusText);

        // If completed, send completion message
        if (completed >= total)
        {
            PostMessage(pThis->m_hwnd, WM_COPY_COMPLETE, (WPARAM)true, 0);
        }
    }
}

=================================================================
FILE: FileCopier.cpp
=================================================================

#include "../include/FileCopier.h"
#include <C:/temp/boost_1_88_0/boost/thread.hpp>
#include <C:/temp/boost_1_88_0/boost/thread/mutex.hpp>
#include <C:/temp/boost_1_88_0/boost/thread/condition_variable.hpp>
#include <C:/temp/boost_1_88_0/boost/chrono.hpp>
#include <shlwapi.h>
#include <algorithm>
#include <strsafe.h>

#pragma comment(lib, "shlwapi.lib")

// Task tracking structure
struct CopyTask {
    int packetIndex;
    LARGE_INTEGER offset;
    DWORD packetSize;
    boost::chrono::steady_clock::time_point startTime;
    boost::atomic<bool> inProgress;
    int assignedSourceIndex;

    CopyTask(int index, LARGE_INTEGER offs, DWORD size)
        : packetIndex(index), offset(offs), packetSize(size),
        inProgress(false), assignedSourceIndex(-1) {
    }
};

// Thread procedure implementation
DWORD WINAPI CopyThreadProc(LPVOID lpParameter)
{
    CopyThreadParam* pParam = static_cast<CopyThreadParam*>(lpParameter);
    if (pParam && pParam->pCopier)
    {
        pParam->pCopier->DoCopyOperation();
    }
    return 0;
}

// Constructor
FileCopier::FileCopier()
    : m_packetSize(65536),
    m_thread(NULL),
    m_operationInProgress(false),
    m_totalPackets(0),
    m_completedPackets(0),
    m_progressCallback(nullptr),
    m_userData(nullptr)
{
    // Create cancel event (manual reset)
    m_cancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // Initialize critical section for thread safety
    InitializeCriticalSection(&m_cs);

    // Allocate reusable buffer
    m_buffer = std::make_unique<BYTE[]>(BUFFER_SIZE);
}

// Destructor
FileCopier::~FileCopier()
{
    // Cancel any ongoing operation
    Cancel();

    // Wait for thread to exit
    if (m_thread)
    {
        WaitForSingleObject(m_thread, INFINITE);
        CloseHandle(m_thread);
        m_thread = NULL;
    }

    // Close event handle
    if (m_cancelEvent)
    {
        CloseHandle(m_cancelEvent);
        m_cancelEvent = NULL;
    }

    // Delete critical section
    DeleteCriticalSection(&m_cs);
}

// Add a source file
void FileCopier::AddSource(const std::wstring& path)
{
    // Don't modify sources during an operation
    if (m_operationInProgress)
        return;

    // Check if source already exists
    for (const auto& source : m_sources)
    {
        if (_wcsicmp(source.path.c_str(), path.c_str()) == 0)
            return;  // Source already exists
    }

    // Add the source
    SourceInfo info;
    info.path = path;
    info.status = L"Ready";
    info.speed = 0;

    m_sources.push_back(info);
}

// Remove a source file
void FileCopier::RemoveSource(size_t index)
{
    // Don't modify sources during an operation
    if (m_operationInProgress)
        return;

    if (index < m_sources.size())
    {
        m_sources.erase(m_sources.begin() + index);
    }
}

// Clear all sources
void FileCopier::ClearSources()
{
    // Don't modify sources during an operation
    if (m_operationInProgress)
        return;

    m_sources.clear();
}

// Get list of sources
const std::vector<SourceInfo>& FileCopier::GetSources() const
{
    return m_sources;
}

// Start copying files
bool FileCopier::StartCopy(
    const std::wstring& destinationPath,
    ProgressCallbackFunc progressCallback,
    void* userData,
    int packetSize)
{
    // Check if already in progress
    if (m_operationInProgress)
        return false;

    // Check if we have sources
    if (m_sources.empty())
        return false;

    // Get the first source file information to determine size
    WIN32_FILE_ATTRIBUTE_DATA fileInfo;
    if (!GetFileAttributesEx(m_sources[0].path.c_str(), GetFileExInfoStandard, &fileInfo))
        return false;

    // Extract filename from the first source
    const wchar_t* fileName = PathFindFileName(m_sources[0].path.c_str());
    if (!fileName || !*fileName)
        return false;

    // Set destination file path
    m_destinationPath = destinationPath;

    // Ensure the destination path ends with a backslash
    if (!m_destinationPath.empty() && m_destinationPath.back() != L'\\')
        m_destinationPath += L'\\';

    // Append the filename to get the full destination path
    m_destinationFilename = m_destinationPath + fileName;

    // Store parameters
    m_packetSize = packetSize;
    m_progressCallback = progressCallback;
    m_userData = userData;

    // Calculate total number of packets
    LARGE_INTEGER fileSize;
    fileSize.HighPart = fileInfo.nFileSizeHigh;
    fileSize.LowPart = fileInfo.nFileSizeLow;

    m_totalPackets = static_cast<int>((fileSize.QuadPart + m_packetSize - 1) / m_packetSize);
    m_completedPackets = 0;

    // Reset cancel event
    ResetEvent(m_cancelEvent);

    // Set operation as in progress
    m_operationInProgress = true;

    // Create worker thread
    m_threadParam.pCopier = this;
    m_thread = CreateThread(
        NULL,                           // Default security attributes
        0,                              // Default stack size
        CopyThreadProc,                 // Thread function
        &m_threadParam,                 // Parameter to thread function
        0,                              // Default creation flags
        NULL);                          // Receive thread identifier

    if (!m_thread)
    {
        m_operationInProgress = false;
        return false;
    }

    return true;
}

// Cancel the copy operation
void FileCopier::Cancel()
{
    if (m_operationInProgress && m_thread && m_cancelEvent)
    {
        // Signal the cancel event
        SetEvent(m_cancelEvent);

        // Wait for thread to exit (with timeout)
        if (WaitForSingleObject(m_thread, 5000) == WAIT_TIMEOUT)
        {
            // Force terminate the thread if it doesn't exit gracefully
#pragma warning(suppress: 6258) // Intentional force termination after timeout
            TerminateThread(m_thread, 1);
        }

        // Clean up
        CloseHandle(m_thread);
        m_thread = NULL;
        m_operationInProgress = false;
    }
}

// Check if a copy is in progress
bool FileCopier::IsOperationInProgress() const
{
    return m_operationInProgress;
}

// Copy a single packet from source to destination
bool FileCopier::CopyPacket(
    const std::wstring& sourcePath,
    HANDLE hDestFile,
    LARGE_INTEGER offset,
    DWORD packetSize,
    int packetIndex,
    BYTE* buffer)
{
    // Open the source file
    HANDLE hSrcFile = CreateFile(
        sourcePath.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL);

    if (hSrcFile == INVALID_HANDLE_VALUE)
    {
        return false;
    }

    // Seek to the correct position in the source file
    if (SetFilePointerEx(hSrcFile, offset, NULL, FILE_BEGIN) == FALSE)
    {
        CloseHandle(hSrcFile);
        return false;
    }

    // Seek to the correct position in the destination file
    if (SetFilePointerEx(hDestFile, offset, NULL, FILE_BEGIN) == FALSE)
    {
        CloseHandle(hSrcFile);
        return false;
    }

    // Read from source and write to destination in chunks for better memory management
    bool success = true;
    DWORD totalBytesRead = 0;

    while (totalBytesRead < packetSize)
    {
        // Check for cancel event
        if (WaitForSingleObject(m_cancelEvent, 0) == WAIT_OBJECT_0)
        {
            success = false;
            break;
        }

        // Calculate chunk size (using our fixed buffer)
        DWORD chunkSize = min(BUFFER_SIZE, packetSize - totalBytesRead);

        // Read from source
        DWORD bytesRead = 0;
        if (!ReadFile(hSrcFile, buffer, chunkSize, &bytesRead, NULL) || bytesRead == 0)
        {
            success = false;
            break;
        }

        // Write to destination
        DWORD bytesWritten = 0;
        if (!WriteFile(hDestFile, buffer, bytesRead, &bytesWritten, NULL) || bytesWritten != bytesRead)
        {
            success = false;
            break;
        }

        totalBytesRead += bytesRead;

        // If we read less than requested, we've reached the end of the file
        if (bytesRead < chunkSize)
            break;
    }

    // Close the source file
    CloseHandle(hSrcFile);

    return success;
}

void FileCopier::DoCopyOperation()
{
    // Create the destination directory if it doesn't exist
    if (!CreateDirectory(m_destinationPath.c_str(), NULL))
    {
        // Check if the error was because the directory already exists
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
            // Directory creation failed and it doesn't exist
            EnterCriticalSection(&m_cs);
            m_operationInProgress = false;
            LeaveCriticalSection(&m_cs);
            return;
        }
    }

    // Create the destination file
    HANDLE hDestFile = CreateFile(
        m_destinationFilename.c_str(),
        GENERIC_WRITE,
        0,  // No sharing
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL);

    if (hDestFile == INVALID_HANDLE_VALUE)
    {
        EnterCriticalSection(&m_cs);
        m_operationInProgress = false;
        LeaveCriticalSection(&m_cs);
        return;
    }

    // Get file size from first source
    WIN32_FILE_ATTRIBUTE_DATA fileInfo;
    LARGE_INTEGER fileSize = { 0 };
    if (GetFileAttributesEx(m_sources[0].path.c_str(), GetFileExInfoStandard, &fileInfo))
    {
        fileSize.HighPart = fileInfo.nFileSizeHigh;
        fileSize.LowPart = fileInfo.nFileSizeLow;

        // Pre-allocate the destination file for better performance
        LARGE_INTEGER distPos = { 0 };
        SetFilePointerEx(hDestFile, fileSize, NULL, FILE_BEGIN);
        SetEndOfFile(hDestFile);
        SetFilePointerEx(hDestFile, distPos, NULL, FILE_BEGIN);
    }

    // Create task queue and synchronization objects
    std::queue<std::shared_ptr<CopyTask>> taskQueue;
    std::vector<std::shared_ptr<CopyTask>> inProgressTasks;
    std::vector<std::shared_ptr<CopyTask>> completedTasks;
    boost::mutex queueMutex;
    boost::condition_variable condVar;
    boost::atomic<bool> shutdownThreads(false);

    // Populate task queue with all packets to copy
    for (int i = 0; i < m_totalPackets; i++)
    {
        LARGE_INTEGER offset;
        offset.QuadPart = static_cast<LONGLONG>(i) * static_cast<LONGLONG>(m_packetSize);

        // Calculate actual packet size (last packet might be smaller)
        DWORD actualPacketSize = m_packetSize;
        if (i == m_totalPackets - 1 && fileSize.QuadPart > 0)
        {
            LONGLONG remaining = fileSize.QuadPart - offset.QuadPart;
            if (remaining < actualPacketSize)
                actualPacketSize = static_cast<DWORD>(remaining);
        }

        taskQueue.push(std::make_shared<CopyTask>(i, offset, actualPacketSize));
    }

    // Create source performance tracking
    std::vector<double> sourceSpeed(m_sources.size(), 0.0);  // Speed in bytes/ms
    std::vector<int> tasksCompleted(m_sources.size(), 0);
    std::vector<bool> sourceActive(m_sources.size(), true);

    // Create worker threads (one per source)
    boost::thread_group workerThreads;
    for (size_t sourceIndex = 0; sourceIndex < m_sources.size(); sourceIndex++)
    {
        workerThreads.create_thread([this, sourceIndex, &taskQueue, &inProgressTasks, &completedTasks,
            &queueMutex, &condVar, &shutdownThreads, &sourceSpeed, &tasksCompleted,
            &sourceActive, hDestFile]() {

                std::shared_ptr<CopyTask> currentTask;
                bool hasTask = false;

                while (!shutdownThreads)
                {
                    // Get a task from the queue or wait for work
                    {
                        boost::unique_lock<boost::mutex> lock(queueMutex);

                        // If we don't have a task, try to get one
                        if (!hasTask)
                        {
                            // Check if there are pending tasks
                            if (!taskQueue.empty())
                            {
                                currentTask = taskQueue.front();
                                taskQueue.pop();
                                hasTask = true;
                                currentTask->inProgress = true;
                                currentTask->assignedSourceIndex = sourceIndex;
                                currentTask->startTime = boost::chrono::steady_clock::now();
                                inProgressTasks.push_back(currentTask);
                            }
                            else
                            {
                                // No tasks available, wait for signal or check completed
                                condVar.wait_for(lock, boost::chrono::milliseconds(100));
                                continue;
                            }
                        }
                    }

                    // Process the task
                    if (hasTask)
                    {
                        // Try to copy the packet from our assigned source
                        auto startTime = boost::chrono::steady_clock::now();
                        bool copied = CopyPacket(m_sources[sourceIndex].path, hDestFile,
                            currentTask->offset, currentTask->packetSize,
                            currentTask->packetIndex, m_buffer.get());
                        auto endTime = boost::chrono::steady_clock::now();

                        // Calculate performance metrics
                        auto elapsedMs = boost::chrono::duration_cast<boost::chrono::milliseconds>(endTime - startTime).count();
                        if (elapsedMs > 0 && copied)
                        {
                            double bytesPerMs = static_cast<double>(currentTask->packetSize) / elapsedMs;

                            // Update source speed with exponential moving average
                            boost::unique_lock<boost::mutex> lock(queueMutex);
                            if (sourceSpeed[sourceIndex] == 0.0)
                                sourceSpeed[sourceIndex] = bytesPerMs;
                            else
                                sourceSpeed[sourceIndex] = sourceSpeed[sourceIndex] * 0.7 + bytesPerMs * 0.3;

                            tasksCompleted[sourceIndex]++;
                        }

                        {
                            boost::unique_lock<boost::mutex> lock(queueMutex);

                            // Mark task as completed or requeue if failed
                            if (copied)
                            {
                                // Remove from in-progress
                                auto it = std::find(inProgressTasks.begin(), inProgressTasks.end(), currentTask);
                                if (it != inProgressTasks.end())
                                    inProgressTasks.erase(it);

                                // Add to completed
                                completedTasks.push_back(currentTask);

                                // Update progress
                                EnterCriticalSection(&m_cs);
                                m_completedPackets++;
                                int completed = m_completedPackets;
                                LeaveCriticalSection(&m_cs);

                                // Report progress
                                if (m_progressCallback)
                                {
                                    m_progressCallback(completed, m_totalPackets, m_userData);
                                }

                                // Mark as not having a task
                                hasTask = false;
                                currentTask = nullptr;
                            }
                            else
                            {
                                // Failed to copy from this source
                                // Check if we've tried too many times with this source
                                if (!sourceActive[sourceIndex] || WaitForSingleObject(m_cancelEvent, 0) == WAIT_OBJECT_0)
                                {
                                    // Source has been marked as inactive or operation cancelled
                                    // Put the task back in the queue for another source to try
                                    taskQueue.push(currentTask);

                                    // Remove from in-progress
                                    auto it = std::find(inProgressTasks.begin(), inProgressTasks.end(), currentTask);
                                    if (it != inProgressTasks.end())
                                        inProgressTasks.erase(it);

                                    // Mark as not having a task
                                    hasTask = false;
                                    currentTask = nullptr;

                                    // Notify other threads that work is available
                                    condVar.notify_all();
                                }
                                else
                                {
                                    // Source is still active, let's try again with backoff
                                    lock.unlock();
                                    Sleep(100);  // Small backoff

                                    // We'll retry with the same task
                                    // hasTask remains true
                                }
                            }
                        }

                        // Check for cancel event
                        if (WaitForSingleObject(m_cancelEvent, 0) == WAIT_OBJECT_0)
                        {
                            shutdownThreads = true;
                            break;
                        }
                    }

                    // Periodically check if any sources should be deactivated due to poor performance
                    if (tasksCompleted[sourceIndex] > 5)  // Need enough samples
                    {
                        boost::unique_lock<boost::mutex> lock(queueMutex);

                        // Find fastest source
                        double maxSpeed = 0.0;
                        for (size_t i = 0; i < m_sources.size(); i++)
                        {
                            if (sourceActive[i] && sourceSpeed[i] > maxSpeed)
                                maxSpeed = sourceSpeed[i];
                        }

                        // If this source is significantly slower than the fastest, mark it inactive
                        if (maxSpeed > 0 && sourceSpeed[sourceIndex] < maxSpeed * 0.5)
                        {
                            sourceActive[sourceIndex] = false;

                            // If we have a task, put it back in the queue
                            if (hasTask)
                            {
                                taskQueue.push(currentTask);

                                // Remove from in-progress
                                auto it = std::find(inProgressTasks.begin(), inProgressTasks.end(), currentTask);
                                if (it != inProgressTasks.end())
                                    inProgressTasks.erase(it);

                                hasTask = false;
                                currentTask = nullptr;

                                // Notify other threads
                                condVar.notify_all();
                            }
                        }
                    }
                }
            });
    }

    // Monitor thread to handle abandoned tasks and operation completion
    boost::thread monitorThread([this, &taskQueue, &inProgressTasks, &completedTasks,
        &queueMutex, &condVar, &shutdownThreads, &sourceSpeed, &sourceActive]() {

            while (!shutdownThreads)
            {
                // Sleep a bit to avoid spinning
                Sleep(500);

                // Check for cancel event
                if (WaitForSingleObject(m_cancelEvent, 0) == WAIT_OBJECT_0)
                {
                    shutdownThreads = true;
                    condVar.notify_all();
                    break;
                }

                // Check for completion
                boost::unique_lock<boost::mutex> lock(queueMutex);
                if (taskQueue.empty() && inProgressTasks.empty())
                {
                    // All tasks are completed or in progress
                    if (completedTasks.size() == m_totalPackets)
                    {
                        // All tasks complete
                        shutdownThreads = true;
                        condVar.notify_all();
                        break;
                    }
                }

                // Check for stuck/slow tasks
                auto now = boost::chrono::steady_clock::now();
                for (auto it = inProgressTasks.begin(); it != inProgressTasks.end();)
                {
                    auto task = *it;
                    auto elapsedMs = boost::chrono::duration_cast<boost::chrono::milliseconds>(
                        now - task->startTime).count();

                    // If a task has been in progress too long, requeue it
                    if (elapsedMs > 10000)  // 10 seconds timeout
                    {
                        // Requeue the task
                        taskQueue.push(task);
                        it = inProgressTasks.erase(it);

                        // Mark the source as potentially problematic
                        if (task->assignedSourceIndex >= 0 && task->assignedSourceIndex < sourceActive.size())
                        {
                            sourceActive[task->assignedSourceIndex] = false;
                        }

                        // Notify worker threads
                        condVar.notify_all();
                    }
                    else
                    {
                        ++it;
                    }
                }
            }
        });

    // Wait for all threads to finish
    monitorThread.join();
    workerThreads.join_all();

    // Close the destination file
    CloseHandle(hDestFile);

    // Operation completed
    EnterCriticalSection(&m_cs);
    m_operationInProgress = false;
    LeaveCriticalSection(&m_cs);
}

